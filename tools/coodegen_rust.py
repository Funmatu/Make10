import itertools
from fractions import Fraction
import sys
import os

# --- 設定 ---
OPS = [
    (lambda x, y: x + y, "+"),
    (lambda x, y: x - y, "-"),
    (lambda x, y: x * y, "*"),
    (lambda x, y: None if y == 0 else x / y, "/"),
]


def get_all_solutions(nums):
    """4つの数字に対する全解を探索"""
    found_exprs = set()
    unique_permutations = set(itertools.permutations(nums))

    for p in unique_permutations:
        a, b, c, d = [Fraction(x) for x in p]

        for op1, op2, op3 in itertools.product(OPS, repeat=3):
            f1, s1 = op1
            f2, s2 = op2
            f3, s3 = op3

            # Pattern 1: ((A op B) op C) op D
            try:
                r1 = f1(a, b)
                if r1 is not None:
                    r2 = f2(r1, c)
                    if r2 is not None:
                        res = f3(r2, d)
                        if res is not None and res == 10:
                            found_exprs.add(f"(({p[0]}{s1}{p[1]}){s2}{p[2]}){s3}{p[3]}")
            except:
                pass

            # Pattern 2: (A op B) op (C op D)
            try:
                rl = f1(a, b)
                rr = f2(c, d)
                if rl is not None and rr is not None:
                    res = f3(rl, rr)
                    if res is not None and res == 10:
                        found_exprs.add(f"({p[0]}{s1}{p[1]}){s3}({p[2]}{s2}{p[3]})")
            except:
                pass

    return sorted(list(found_exprs))


def generate_rust_source():
    """
    Rustの静的配列コードを生成する。
    インデックス = a*1000 + b*100 + c*10 + d (0000-9999)
    これにより実行時は配列アクセス1回(O(1))で解に到達できる。
    """
    print("Generating Lookup Table...", file=sys.stderr)

    # 配列サイズは 9999 + 1 = 10000
    # インデックスに対応する解のリストを格納
    table_data = ["&[]"] * 10000

    combinations = list(itertools.combinations_with_replacement(range(10), 4))
    count = 0

    for combo in combinations:
        # キー計算: 正規化(ソート)してから数値化
        # 例: (1,4,5,7) -> 1457
        key_tuple = sorted(combo)
        idx = (
            key_tuple[0] * 1000 + key_tuple[1] * 100 + key_tuple[2] * 10 + key_tuple[3]
        )

        solutions = get_all_solutions(combo)
        if solutions:
            # Rustの文字列表現に変換
            strs = ", ".join([f'"{s}"' for s in solutions])
            table_data[idx] = f"&[{strs}]"
            count += 1

    print(f"Solved {count} patterns.", file=sys.stderr)

    # Rustコード出力
    lines = []
    lines.append("// Auto-generated by tools/codegen_rust.py")
    lines.append("// This file contains the pre-computed solutions for Make10.")
    lines.append("")
    lines.append("pub static SOLUTIONS: [&[&str]; 10000] = [")

    # 10000行書き出すと長すぎるので、適宜改行を入れるが、
    # ここではシンプルに1行ずつ出力する（コンパイラは処理できる）
    for i, val in enumerate(table_data):
        lines.append(f"    {val}, // {i:04d}")

    lines.append("];")

    return "\n".join(lines)


if __name__ == "__main__":
    src = generate_rust_source()
    os.makedirs("src", exist_ok=True)
    with open("src/generated_table.rs", "w", encoding="utf-8") as f:
        f.write(src)
    print("Done: src/generated_table.rs")
